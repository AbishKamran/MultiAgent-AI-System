# Multi-Agent AI System using Google ADK
# A sophisticated system that chains agents to achieve complex goals

import os
import json
import asyncio
import aiohttp
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import logging
from abc import ABC, abstractmethod

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AgentStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class AgentResult:
    """Standard result format for all agents"""
    agent_id: str
    status: AgentStatus
    data: Dict[str, Any]
    metadata: Dict[str, Any]
    timestamp: str
    error_message: Optional[str] = None

@dataclass
class ExecutionPlan:
    """Plan generated by the Planner Agent"""
    goal: str
    agent_sequence: List[str]
    dependencies: Dict[str, List[str]]
    estimated_duration: int
    created_at: str

class BaseAgent(ABC):
    """Abstract base class for all agents"""
    
    def __init__(self, agent_id: str, api_keys: Dict[str, str]):
        self.agent_id = agent_id
        self.api_keys = api_keys
        self.status = AgentStatus.PENDING
        
    @abstractmethod
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Execute the agent's main functionality"""
        pass
    
    def _create_result(self, data: Dict[str, Any], status: AgentStatus = AgentStatus.COMPLETED, 
                      error_message: str = None) -> AgentResult:
        """Helper to create standardized results"""
        return AgentResult(
            agent_id=self.agent_id,
            status=status,
            data=data,
            metadata={"execution_time": datetime.now().isoformat()},
            timestamp=datetime.now().isoformat(),
            error_message=error_message
        )

class PlannerAgent(BaseAgent):
    """Master planner that creates execution plans for goals"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("planner", api_keys)
        self.goal_templates = {
            "spacex_weather": {
                "agents": ["spacex_agent", "weather_agent", "analyzer_agent"],
                "description": "Get SpaceX launch data, check weather, analyze delay probability"
            },
            "crypto_news": {
                "agents": ["crypto_agent", "news_agent", "sentiment_agent"],
                "description": "Get crypto prices, fetch related news, analyze sentiment"
            },
            "general": {
                "agents": ["data_agent", "enrichment_agent", "analyzer_agent"],
                "description": "Generic data gathering and analysis pipeline"
            }
        }
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Create an execution plan based on the user goal"""
        try:
            goal = input_data.get("goal", "").lower()
            
            # Intelligent goal classification
            if "spacex" in goal or "launch" in goal:
                template = self.goal_templates["spacex_weather"]
            elif "crypto" in goal or "bitcoin" in goal or "ethereum" in goal:
                template = self.goal_templates["crypto_news"]
            else:
                template = self.goal_templates["general"]
            
            plan = ExecutionPlan(
                goal=input_data["goal"],
                agent_sequence=template["agents"],
                dependencies=self._create_dependencies(template["agents"]),
                estimated_duration=len(template["agents"]) * 30,  # 30 seconds per agent
                created_at=datetime.now().isoformat()
            )
            
            return self._create_result({
                "plan": asdict(plan),
                "strategy": template["description"]
            })
            
        except Exception as e:
            logger.error(f"Planner failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))
    
    def _create_dependencies(self, agents: List[str]) -> Dict[str, List[str]]:
        """Create dependency mapping where each agent depends on the previous"""
        dependencies = {}
        for i, agent in enumerate(agents):
            if i == 0:
                dependencies[agent] = []
            else:
                dependencies[agent] = [agents[i-1]]
        return dependencies

class SpaceXAgent(BaseAgent):
    """Agent to fetch SpaceX launch data"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("spacex_agent", api_keys)
        self.base_url = "https://api.spacexdata.com/v4"
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Fetch next SpaceX launch information"""
        try:
            async with aiohttp.ClientSession() as session:
                # Get upcoming launches
                async with session.get(f"{self.base_url}/launches/upcoming") as response:
                    launches = await response.json()
                
                if not launches:
                    return self._create_result({
                        "launch": None,
                        "message": "No upcoming launches found"
                    })
                
                # Get the next launch
                next_launch = launches[0]
                
                # Get launchpad details
                launchpad_id = next_launch.get("launchpad")
                launchpad_data = {}
                
                if launchpad_id:
                    async with session.get(f"{self.base_url}/launchpads/{launchpad_id}") as response:
                        launchpad_data = await response.json()
                
                result_data = {
                    "launch": {
                        "name": next_launch.get("name"),
                        "date_utc": next_launch.get("date_utc"),
                        "date_local": next_launch.get("date_local"),
                        "flight_number": next_launch.get("flight_number"),
                        "details": next_launch.get("details")
                    },
                    "location": {
                        "name": launchpad_data.get("full_name"),
                        "locality": launchpad_data.get("locality"),
                        "region": launchpad_data.get("region"),
                        "latitude": launchpad_data.get("latitude"),
                        "longitude": launchpad_data.get("longitude")
                    }
                }
                
                logger.info(f"SpaceX Agent: Found launch {next_launch.get('name')} at {launchpad_data.get('full_name')}")
                return self._create_result(result_data)
                
        except Exception as e:
            logger.error(f"SpaceX Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class WeatherAgent(BaseAgent):
    """Agent to fetch weather data for launch location"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("weather_agent", api_keys)
        self.api_key = api_keys.get("OPENWEATHER_API_KEY")
        self.base_url = "https://api.openweathermap.org/data/2.5"
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Fetch weather data for the launch location"""
        try:
            # Extract location from previous agent's output - FIXED BUG HERE
            spacex_result = input_data.get("spacex_agent")
            if not spacex_result or not hasattr(spacex_result, 'data'):
                return self._create_result({}, AgentStatus.FAILED, "No SpaceX agent data available")
            
            spacex_data = spacex_result.data
            location = spacex_data.get("location", {})
            
            if not location.get("latitude") or not location.get("longitude"):
                return self._create_result({}, AgentStatus.FAILED, "No location data from SpaceX agent")
            
            if not self.api_key:
                # Return mock data if no API key
                result_data = {
                    "current": {
                        "temperature": 22.5,
                        "humidity": 65,
                        "pressure": 1013,
                        "wind_speed": 8.5,
                        "wind_direction": 180,
                        "description": "clear sky",
                        "visibility": 10.0
                    },
                    "forecast": [
                        {
                            "datetime": "2024-02-15 12:00:00",
                            "temperature": 24.0,
                            "wind_speed": 10.0,
                            "precipitation": 0,
                            "description": "partly cloudy"
                        }
                    ]
                }
                logger.info(f"Weather Agent: Using mock data (no API key) for {location['name']}")
                return self._create_result(result_data)
            
            lat = location["latitude"]
            lon = location["longitude"]
            
            async with aiohttp.ClientSession() as session:
                # Current weather
                current_url = f"{self.base_url}/weather?lat={lat}&lon={lon}&appid={self.api_key}&units=metric"
                async with session.get(current_url) as response:
                    current_weather = await response.json()
                
                # 5-day forecast
                forecast_url = f"{self.base_url}/forecast?lat={lat}&lon={lon}&appid={self.api_key}&units=metric"
                async with session.get(forecast_url) as response:
                    forecast_data = await response.json()
            
            # Extract relevant weather information
            result_data = {
                "current": {
                    "temperature": current_weather["main"]["temp"],
                    "humidity": current_weather["main"]["humidity"],
                    "pressure": current_weather["main"]["pressure"],
                    "wind_speed": current_weather["wind"]["speed"],
                    "wind_direction": current_weather["wind"].get("deg", 0),
                    "description": current_weather["weather"][0]["description"],
                    "visibility": current_weather.get("visibility", 0) / 1000  # Convert to km
                },
                "forecast": [
                    {
                        "datetime": item["dt_txt"],
                        "temperature": item["main"]["temp"],
                        "wind_speed": item["wind"]["speed"],
                        "precipitation": item.get("rain", {}).get("3h", 0) + item.get("snow", {}).get("3h", 0),
                        "description": item["weather"][0]["description"]
                    }
                    for item in forecast_data["list"][:8]  # Next 24 hours (3-hour intervals)
                ]
            }
            
            logger.info(f"Weather Agent: Retrieved weather for {location['name']}")
            return self._create_result(result_data)
            
        except Exception as e:
            logger.error(f"Weather Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class AnalyzerAgent(BaseAgent):
    """Agent to analyze launch delay probability based on weather"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("analyzer_agent", api_keys)
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Analyze launch delay probability"""
        try:
            # FIXED BUG: Access AgentResult.data properly
            spacex_result = input_data.get("spacex_agent")
            weather_result = input_data.get("weather_agent")
            
            if not spacex_result or not weather_result:
                return self._create_result({}, AgentStatus.FAILED, "Missing input data from previous agents")
            
            spacex_data = spacex_result.data if hasattr(spacex_result, 'data') else {}
            weather_data = weather_result.data if hasattr(weather_result, 'data') else {}
            
            if not spacex_data or not weather_data:
                return self._create_result({}, AgentStatus.FAILED, "Invalid data from previous agents")
            
            # Launch delay risk factors
            risk_factors = []
            delay_probability = 0.0
            
            current = weather_data.get("current", {})
            forecast = weather_data.get("forecast", [])
            
            # Analyze current conditions
            if current.get("wind_speed", 0) > 15:  # m/s
                risk_factors.append("High wind speeds")
                delay_probability += 0.3
            
            if current.get("visibility", 10) < 5:  # km
                risk_factors.append("Poor visibility")
                delay_probability += 0.2
            
            if "rain" in current.get("description", "").lower():
                risk_factors.append("Current precipitation")
                delay_probability += 0.25
            
            if "storm" in current.get("description", "").lower():
                risk_factors.append("Storm conditions")
                delay_probability += 0.4
            
            # Analyze forecast for launch day
            forecast_risks = 0
            for period in forecast:
                if period.get("wind_speed", 0) > 12:
                    forecast_risks += 1
                if period.get("precipitation", 0) > 1:
                    forecast_risks += 1
                if "storm" in period.get("description", "").lower():
                    forecast_risks += 2
            
            if forecast_risks > 3:
                risk_factors.append("Adverse forecast conditions")
                delay_probability += 0.2
            
            # Cap probability at 0.9
            delay_probability = min(delay_probability, 0.9)
            
            # Generate recommendation
            if delay_probability < 0.2:
                recommendation = "Low delay risk - Launch likely to proceed as scheduled"
                risk_level = "LOW"
            elif delay_probability < 0.5:
                recommendation = "Moderate delay risk - Monitor weather conditions closely"
                risk_level = "MODERATE"
            else:
                recommendation = "High delay risk - Launch may be postponed due to weather"
                risk_level = "HIGH"
            
            result_data = {
                "analysis": {
                    "delay_probability": round(delay_probability, 2),
                    "risk_level": risk_level,
                    "risk_factors": risk_factors,
                    "recommendation": recommendation
                },
                "launch_info": {
                    "name": spacex_data.get("launch", {}).get("name"),
                    "date": spacex_data.get("launch", {}).get("date_local"),
                    "location": spacex_data.get("location", {}).get("name")
                },
                "weather_summary": {
                    "current_conditions": current.get("description"),
                    "temperature": current.get("temperature"),
                    "wind_speed": current.get("wind_speed"),
                    "visibility": current.get("visibility")
                }
            }
            
            logger.info(f"Analyzer Agent: Delay probability {delay_probability:.2%}, Risk level: {risk_level}")
            return self._create_result(result_data)
            
        except Exception as e:
            logger.error(f"Analyzer Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class CryptoAgent(BaseAgent):
    """Agent to fetch cryptocurrency data"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("crypto_agent", api_keys)
        self.base_url = "https://api.coingecko.com/api/v3"
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Fetch cryptocurrency market data"""
        try:
            # Extract crypto symbols from goal or use defaults
            goal = input_data.get("goal", "").lower()
            symbols = ["bitcoin", "ethereum"]
            
            if "bitcoin" in goal or "btc" in goal:
                symbols = ["bitcoin"]
            elif "ethereum" in goal or "eth" in goal:
                symbols = ["ethereum"]
            
            async with aiohttp.ClientSession() as session:
                # Get current prices and market data
                ids = ",".join(symbols)
                url = f"{self.base_url}/simple/price?ids={ids}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true"
                
                async with session.get(url) as response:
                    price_data = await response.json()
                
                # Get trending coins
                async with session.get(f"{self.base_url}/search/trending") as response:
                    trending_data = await response.json()
            
            result_data = {
                "prices": price_data,
                "trending": [coin["item"]["name"] for coin in trending_data["coins"][:5]],
                "analyzed_coins": symbols
            }
            
            logger.info(f"Crypto Agent: Retrieved data for {symbols}")
            return self._create_result(result_data)
            
        except Exception as e:
            logger.error(f"Crypto Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class NewsAgent(BaseAgent):
    """Agent to fetch news related to cryptocurrency"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("news_agent", api_keys)
        self.api_key = api_keys.get("NEWS_API_KEY")
        self.base_url = "https://newsapi.org/v2"
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Fetch news articles related to cryptocurrency"""
        try:
            # FIXED BUG: Access AgentResult.data properly
            crypto_result = input_data.get("crypto_agent")
            if not crypto_result or not hasattr(crypto_result, 'data'):
                return self._create_result({}, AgentStatus.FAILED, "No crypto agent data available")
            
            crypto_data = crypto_result.data
            analyzed_coins = crypto_data.get("analyzed_coins", ["bitcoin"])
            
            if not self.api_key:
                # Return mock news data if no API key
                articles = [
                    {
                        "title": f"{analyzed_coins[0].title()} Shows Strong Market Performance",
                        "description": f"Recent analysis shows {analyzed_coins[0]} maintaining steady growth with positive investor sentiment.",
                        "url": "https://example.com/crypto-news-1",
                        "published_at": datetime.now().isoformat(),
                        "source": "Mock Crypto News"
                    },
                    {
                        "title": f"Market Analysis: {analyzed_coins[0].title()} Outlook Remains Bullish",
                        "description": f"Experts predict continued growth for {analyzed_coins[0]} based on recent market trends and adoption.",
                        "url": "https://example.com/crypto-news-2",
                        "published_at": datetime.now().isoformat(),
                        "source": "Mock Financial Times"
                    }
                ]
                
                result_data = {
                    "articles": articles,
                    "total_results": len(articles),
                    "query": " OR ".join(analyzed_coins)
                }
                
                logger.info(f"News Agent: Using mock data (no API key) for {analyzed_coins}")
                return self._create_result(result_data)
            
            # Create search query
            query = " OR ".join(analyzed_coins)
            
            async with aiohttp.ClientSession() as session:
                url = f"{self.base_url}/everything"
                params = {
                    "q": query,
                    "sortBy": "publishedAt",
                    "pageSize": 10,
                    "language": "en",
                    "apiKey": self.api_key
                }
                
                async with session.get(url, params=params) as response:
                    news_data = await response.json()
            
            articles = []
            for article in news_data.get("articles", [])[:5]:
                articles.append({
                    "title": article["title"],
                    "description": article["description"],
                    "url": article["url"],
                    "published_at": article["publishedAt"],
                    "source": article["source"]["name"]
                })
            
            result_data = {
                "articles": articles,
                "total_results": news_data.get("totalResults", 0),
                "query": query
            }
            
            logger.info(f"News Agent: Retrieved {len(articles)} articles for {query}")
            return self._create_result(result_data)
            
        except Exception as e:
            logger.error(f"News Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class SentimentAgent(BaseAgent):
    """Agent to analyze sentiment of news articles"""
    
    def __init__(self, api_keys: Dict[str, str]):
        super().__init__("sentiment_agent", api_keys)
    
    async def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """Analyze sentiment of news articles"""
        try:
            # FIXED BUG: Access AgentResult.data properly
            crypto_result = input_data.get("crypto_agent")
            news_result = input_data.get("news_agent")
            
            if not crypto_result or not news_result:
                return self._create_result({}, AgentStatus.FAILED, "Missing input data from previous agents")
            
            crypto_data = crypto_result.data if hasattr(crypto_result, 'data') else {}
            news_data = news_result.data if hasattr(news_result, 'data') else {}
            
            if not news_data or not news_data.get("articles"):
                return self._create_result({}, AgentStatus.FAILED, "No news articles to analyze")
            
            # Simple sentiment analysis based on keywords
            positive_words = ["surge", "bullish", "growth", "profit", "gain", "up", "rise", "positive", "optimistic"]
            negative_words = ["crash", "bearish", "loss", "down", "fall", "negative", "pessimistic", "decline"]
            
            sentiment_scores = []
            article_sentiments = []
            
            for article in news_data["articles"]:
                text = (article["title"] + " " + (article["description"] or "")).lower()
                
                positive_count = sum(1 for word in positive_words if word in text)
                negative_count = sum(1 for word in negative_words if word in text)
                
                if positive_count > negative_count:
                    sentiment = "positive"
                    score = (positive_count - negative_count) / max(positive_count + negative_count, 1)
                elif negative_count > positive_count:
                    sentiment = "negative"
                    score = -(negative_count - positive_count) / max(positive_count + negative_count, 1)
                else:
                    sentiment = "neutral"
                    score = 0
                
                sentiment_scores.append(score)
                article_sentiments.append({
                    "title": article["title"],
                    "sentiment": sentiment,
                    "score": round(score, 2)
                })
            
            # Overall sentiment
            avg_sentiment = sum(sentiment_scores) / len(sentiment_scores) if sentiment_scores else 0
            
            if avg_sentiment > 0.1:
                overall_sentiment = "positive"
            elif avg_sentiment < -0.1:
                overall_sentiment = "negative"
            else:
                overall_sentiment = "neutral"
            
            # Market impact prediction
            if overall_sentiment == "positive":
                market_impact = "Positive news sentiment may support price appreciation"
            elif overall_sentiment == "negative":
                market_impact = "Negative news sentiment may create selling pressure"
            else:
                market_impact = "Neutral news sentiment unlikely to drive significant price movement"
            
            result_data = {
                "overall_sentiment": overall_sentiment,
                "sentiment_score": round(avg_sentiment, 2),
                "article_sentiments": article_sentiments,
                "market_impact": market_impact,
                "summary": {
                    "analyzed_coins": crypto_data.get("analyzed_coins", []),
                    "price_data": crypto_data.get("prices", {}),
                    "articles_analyzed": len(article_sentiments)
                }
            }
            
            logger.info(f"Sentiment Agent: Overall sentiment {overall_sentiment} (score: {avg_sentiment:.2f})")
            return self._create_result(result_data)
            
        except Exception as e:
            logger.error(f"Sentiment Agent failed: {str(e)}")
            return self._create_result({}, AgentStatus.FAILED, str(e))

class MultiAgentOrchestrator:
    """Main orchestrator that manages agent execution and data flow"""
    
    def __init__(self, api_keys: Dict[str, str]):
        self.api_keys = api_keys
        self.agents = {
            "planner": PlannerAgent(api_keys),
            "spacex_agent": SpaceXAgent(api_keys),
            "weather_agent": WeatherAgent(api_keys),
            "analyzer_agent": AnalyzerAgent(api_keys),
            "crypto_agent": CryptoAgent(api_keys),
            "news_agent": NewsAgent(api_keys),
            "sentiment_agent": SentimentAgent(api_keys)
        }
        self.execution_history = []
        self.max_iterations = 3
    
    async def execute_goal(self, goal: str) -> Dict[str, Any]:
        """Execute a user goal through the multi-agent system"""
        logger.info(f"Starting execution for goal: {goal}")
        
        # Phase 1: Planning
        planner_result = await self.agents["planner"].execute({"goal": goal})
        
        if planner_result.status == AgentStatus.FAILED:
            return {"error": "Planning failed", "details": planner_result.error_message}
        
        plan = planner_result.data["plan"]
        agent_sequence = plan["agent_sequence"]
        
        logger.info(f"Execution plan: {agent_sequence}")
        
        # Phase 2: Execute agents in sequence
        results = {"planner": planner_result}
        iteration = 0
        
        while iteration < self.max_iterations:
            iteration += 1
            logger.info(f"Iteration {iteration}")
            
            success = True
            for agent_id in agent_sequence:
                if agent_id not in self.agents:
                    logger.error(f"Agent {agent_id} not found")
                    success = False
                    break
                
                # FIXED BUG: Prepare input data with results from all previous agents
                input_data = {"goal": goal}
                for prev_agent, prev_result in results.items():
                    if prev_agent != "planner":
                        input_data[prev_agent] = prev_result
                
                # Execute agent
                logger.info(f"Executing {agent_id}")
                result = await self.agents[agent_id].execute(input_data)
                results[agent_id] = result
                
                if result.status == AgentStatus.FAILED:
                    logger.error(f"Agent {agent_id} failed: {result.error_message}")
                    success = False
                    break
            
            if success:
                logger.info("All agents executed successfully")
                break
            else:
                logger.info(f"Iteration {iteration} failed, retrying...")
                if iteration >= self.max_iterations:
                    logger.error("Max iterations reached, execution failed")
        
        # Phase 3: Compile final result
        final_result = {
            "goal": goal,
            "success": success,
            "iterations": iteration,
            "execution_plan": plan,
            "results": {k: asdict(v) for k, v in results.items()},
            "final_output": self._extract_final_output(results, agent_sequence)
        }
        
        self.execution_history.append(final_result)
        return final_result
    
    def _extract_final_output(self, results: Dict[str, AgentResult], sequence: List[str]) -> Dict[str, Any]:
        """Extract the most relevant output from the final agent"""
        if not sequence:
            return {}
        
        final_agent = sequence[-1]
        if final_agent in results:
            return results[final_agent].data
        return {}
    
    def get_execution_history(self) -> List[Dict[str, Any]]:
        """Get the history of all executions"""
        return self.execution_history

# Main execution function
async def main():
    """Example usage of the multi-agent system"""
    
    # Load API keys from environment
    api_keys = {
        "OPENWEATHER_API_KEY": os.getenv("OPENWEATHER_API_KEY"),
        "NEWS_API_KEY": os.getenv("NEWS_API_KEY")
    }
    
    # Create orchestrator
    orchestrator = MultiAgentOrchestrator(api_keys)
    
    # Example goals
    goals = [
        "Find the next SpaceX launch, check weather at that location, then summarize if it may be delayed",
        "Get Bitcoin price and recent news, then analyze market sentiment"
    ]
    
    for goal in goals:
        print(f"\n{'='*60}")
        print(f"EXECUTING GOAL: {goal}")
        print(f"{'='*60}")
        
        result = await orchestrator.execute_goal(goal)
        
        print(f"\nResult Summary:")
        print(f"Success: {result['success']}")
        print(f"Iterations: {result['iterations']}")
        
        if result['success']:
            final_output = result['final_output']
            print(f"\nFinal Output:")
            print(json.dumps(final_output, indent=2))
        else:
            print(f"Execution failed after {result['iterations']} iterations")

if __name__ == "__main__":
    asyncio.run(main())